import threading
import time

import numpy as np
import torch
import tyro
from loguru import logger

from lib_mosca.dynamic_gs import DynSCFGaussian
from lib_mosca.static_gs import StaticGaussian
from lib_render.render_helper import render

import viser
import nerfview
import os.path as osp


def add_gui_playback_group(
    server: viser.ViserServer,
    num_frames: int,
    min_fps: float = 1.0,
    max_fps: float = 60.0,
    fps_step: float = 0.1,
    initial_fps: float = 10.0,
):
    gui_timestep = server.gui.add_slider(
        "Timestep",
        min=0,
        max=num_frames - 1,
        step=1,
        initial_value=0,
        disabled=False,
    )
    gui_next_frame = server.gui.add_button("Next Frame")
    gui_prev_frame = server.gui.add_button("Prev Frame")
    gui_playing_pause = server.gui.add_button("Pause")
    gui_playing_pause.visible = False
    gui_playing_resume = server.gui.add_button("Resume")
    gui_framerate = server.gui.add_slider(
        "FPS", min=min_fps, max=max_fps, step=fps_step, initial_value=initial_fps
    )

    # Frame step buttons.
    @gui_next_frame.on_click
    def _(_) -> None:
        gui_timestep.value = (gui_timestep.value + 1) % num_frames

    @gui_prev_frame.on_click
    def _(_) -> None:
        gui_timestep.value = (gui_timestep.value - 1) % num_frames

    # Disable frame controls when we're playing.
    def _toggle_gui_playing(_):
        gui_playing_pause.visible = not gui_playing_pause.visible
        gui_playing_resume.visible = not gui_playing_resume.visible
        gui_timestep.disabled = gui_playing_pause.visible
        gui_next_frame.disabled = gui_playing_pause.visible
        gui_prev_frame.disabled = gui_playing_pause.visible

    gui_playing_pause.on_click(_toggle_gui_playing)
    gui_playing_resume.on_click(_toggle_gui_playing)

    # Create a thread to update the timestep indefinitely.
    def _update_timestep():
        while True:
            if gui_playing_pause.visible:
                gui_timestep.value = (gui_timestep.value + 1) % num_frames
            time.sleep(1 / gui_framerate.value)

    threading.Thread(target=_update_timestep, daemon=True).start()

    return (
        gui_timestep,
        gui_next_frame,
        gui_prev_frame,
        gui_playing_pause,
        gui_playing_resume,
        gui_framerate,
    )


def main(ws: str, port=8890, device: str = "cuda"):
    rdevice = torch.device(device)
    server = viser.ViserServer(verbose=False)

    s_model = StaticGaussian.load_from_ckpt(
        torch.load(osp.join(ws, "photometric_s_model_native_add3.pth")),
        device=rdevice,
    )
    s_model.eval()
    d_model = DynSCFGaussian.load_from_ckpt(
        torch.load(osp.join(ws, "photometric_d_model_native_add3.pth")),
        device=rdevice,
    )
    # d_model.set_inference_mode()

    gui_up = server.gui.add_vector3(
        "Up Direction",
        initial_value=(0.0, -1.0, -1.0),
        step=0.01,
    )

    @gui_up.on_update
    def _(_) -> None:
        server.scene.set_up_direction(gui_up.value)

    (
        gui_timestep,
        gui_next_frame,
        gui_prev_frame,
        gui_playing_pause,
        gui_playing_resume,
        gui_framerate,
    ) = add_gui_playback_group(server=server, num_frames=d_model.T)

    @torch.inference_mode()
    def render_fn(
        camera_state: nerfview.CameraState,
        render_tab_state: nerfview.RenderTabState,
    ):
        if render_tab_state.preview_render:
            W = render_tab_state.render_width
            H = render_tab_state.render_height
        else:
            W = render_tab_state.viewer_width
            H = render_tab_state.viewer_height
        focal = 0.5 * H / np.tan(0.5 * camera_state.fov).item()
        K = torch.tensor(
            [[focal, 0.0, W / 2.0], [0.0, focal, H / 2.0], [0.0, 0.0, 1.0]],
            device=device,
            dtype=torch.float32,
        )
        w2c = torch.linalg.inv(
            torch.from_numpy(camera_state.c2w.astype(np.float32)).to(device)
        )
        t = int(gui_timestep.value)

        gs5 = []
        gs5.append(s_model())
        gs5.append(d_model(t))

        # * identyfy the visible GS
        render_dict = render(gs5, H, W, K=K, T_cw=w2c)
        rgb = torch.clamp(render_dict["rgb"].permute(1, 2, 0), 0.0, 1.0)
        img = (rgb.detach().cpu().numpy() * 255).astype(np.uint8)
        return img

    viewer = nerfview.Viewer(server=server, render_fn=render_fn, mode="rendering")

    gui_timestep.on_update(viewer.rerender)

    logger.info(f"Starting rendering at http://localhost:{port}")
    while True:
        time.sleep(1.0)


if __name__ == "__main__":
    tyro.cli(main)
